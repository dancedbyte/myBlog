---
title: HTTP 知识梳理
tags: HTTP
categories: 网络协议
date: 2020-10-04
index_img: /img/http_1_1.jpg
---

## HTTP 工作过程

1. 一次http操作称为一个事务，事务可以分步骤，且每个步骤必须全部操作成功才可认为这次事务成功。否则哪怕一个步骤出错则事务失败。

2. 以下过程，如某个步骤出错的话，错误信息将返回给客户端，即浏览器中见到的404、500等。

    1. 客户机与服务器建立tcp连接。因为http是基于tcp的，所以想建立http必须先建立tcp连接。**即三次握手**。
    
    2. 客户端发送请求，包括请求行、请求报头、请求体。
    
    3. 服务端处理请求后给出响应，包括响应行、响应报头、响应体。
    
    4. 客户端收到返回信息后浏览器开始渲染，并与服务器断开连接。即**四次挥手**。为什么要断开呢？因为一个tcp连接是一个IO操作，很耗资源的，用完之后要及时释放。

## 请求方法
GET：一般用于查询，请求参数在url中。

POST：一般用于添加，请求参数在请求体中。

PUT：修改资源，请求参数在url中。

DELETE：用于删除所标识的资源。

HEAD：让服务器只返回资源的**响应报头**。

TRACE：服务器回送收到的请求信息，一般用于**诊断或测试**。

OPTIONS：预请求，检查服务器的性能。当跨域或人为修改了content-type等请求头，浏览器会自动发起OPTIONS请求。

## HTTP 状态码
1xx：请求已接收，继续处理，可能是继续发送其他的请求。
    
    101：协议协商，服务端告诉客户端需要更换协议才可访问。

2xx：请求被成功的理解和接收。

3xx：重定向，要完成请求必须进行更进一步的操作。
    
    301：永久性移动，资源已经不在之前的地址了。
    302：临时移动。
    304：本地重定向，需要跳转到本地的缓存上。
    305：必须通过代理才能访问该资源。
    
4xx：客户端错误，如语法、请求参数等错误。

    400：错误的请求方式，参数或请求方法不对。
    401：身份验证，没有权限。
    403：服务器拒绝执行该请求。
    404：请求了错误的不存在的路径。
    408：请求时间过长，可能是数据包过大，一直在发的过程中，服务器一直在等待这个请求的过程。
    410：资源已经不存在了，和404的区别是404根本就没有，而410属于原来有现在没有了，服务器只维护资源的一些信息，资源实际不存在了。
    413：发送数据包过大，服务器处理不了。
    

5xx：服务端错误，服务器未能实现合法的响应。

    500：服务器内部错误，例如代码抛出异常。
    501：请求了服务器不支持的功能。
    502：网关错误，如出现502则请求的服务器一定是反向代理，代理服务器向后转发时，接收的服务器挂了。

## TCP/IP 协议栈

<img src='/img/http_1_1.jpg' width='400' />

1. 共有五层。应用层、传输层、网络层、数据链路层、物理层。

    ```
       应用层: 为用户提供所需服务，如http https dns等。               
       传输层：为应用层提供端对端的通信功能，保证数据包的顺序及完整性。
       网络层：解决主机到主机的通信问题，IP协议是网络层重要协议。为主机分配IP及维护IP状态。
       数据链路层：将传输层、网络层传下来的字节流转化成光电信号来让硬件承载。
       物理层：纯硬件，如网线水晶头等。
    ```

2. 只能层与层之间传输，不能跨层，分工明确。

3. **http, https, dns都属于应用层协议**。一般我们最多只能接触到传输层。

4. **传输层**提供 **TCP**传输控制协议 和 **UDP**用户数据报（http3是基于UDP协议）。
    
    ```
    TCP：面向链接的、非常稳定可靠的协议。可以理解为TCP像打电话，双方必须确认通话后，才可进行传输。所以要有三次握手四次挥手。
    UDP：无链接、不能保证数据一定被对方接收到。可以理解为对讲机，不确定对方是否接收到了。
    ```

5. IP协议是网络层重要协议。所说的 TCP/IP 协议其实就是传输层和网络层的协议。

## DNS 解析
DNS 是一个域名名字系统，用来存储域名与 Ip 的对应关系。通俗来说就是一个键值对的列表。接下来说 DNS 解析的具体流程！

1. **先检查本地 hosts 文件**，这个文件是没有拓展名的系统文件，可以在里面配置一些域名与 Ip 的对应关系。这样当我们在浏览器输入一个配置好的域名，则直接从本地 hosts 文件中取。
    
    这样做的好处显而易见就是加快域名解析，不用再去域名系统解析。还有一个用处是可以屏蔽垃圾网站，即将垃圾网站的域名指向一个错误的 Ip。
    
    该文件在 Mac 系统下的目录是： ~/private/etc

2. 如果 hosts 文件没有找到相应配置，则继续检查**本地 DNS 缓存**。mac 下可通过 nslookup 命令查看本地 DNS 解析记录。如下是我本地对某域名的缓存记录 47.94.174.112。

   <img src='/img/http_2_10.png' width=500 />  

3. 如果前两个走不通或者我们是第一次访问一个域名，那么就要**开始访问 DNS 服务器了。DNS 服务器也有自己的缓存，会先在缓存里查找**，如果有的话直接返回。当我们电脑连接网络后，可以查看对应的 DNS 服务器地址。

    点击 系统偏好设置 - 网络 - 高级。则可以看到自己网络对应 DNS 服务器地址。
    
    <img src='/img/http_2_11.png' width=400 />

4. 如果 DNS 缓存没有找到，则**开始 DNS 服务器递归查找**。以访问 www.ghmwin.com 为例。

    ① 询问根域名服务器（下图标注3），获取顶级域名 .com 对应的ip地址
    ② 询问顶级域名服务器（下图标注4），获取二级域名 .ghmwin.com 对应的ip地址
    ③ 询问二级域名服务器（下图标注5），获取三级域名 www.ghmwin.com 对应的ip地址
    ④ 域名解析完成后，DNS 服务器拿到完整的 Ip 地址。DNS 服务器会做一层缓存。
    ⑤ DNS 服务器将最终 Ip 返回给用户，用户拿到后并缓存。

    <img src='/img/http_2_4.png' width=600 />
    
## 建立 TCP 连接

<img src='/img/http_2_5.png' width=400 />

### 常用标志位
SYN: 发起连接； seq: 顺序号； ACK: 确认应答； FIN: 关闭连接

### 三次握手
握手过程中传送的包里**不包含数据**，三次握手完毕后，客户端与服务器才**正式开始传送数据**。理想状态下，TCP 连接一旦建立，只要通信双方不主动关闭连接，则 TCP 连接都将被一直保持下去。

1. 客户端发起连接，并向服务端发送一个顺序号(x)，这个 x 是由客户端自己维护的。

2. 服务端接收到客户端的 x 之后，给加 1 并返回给客户端，同时也要发送一个顺序号(y)给客户端，即 SYN + ACK 包， 这个 y 是由服务端自己维护的。

3. 客户端接收到 y 之后，给加 1 再传回给服务端作为应答码。此包发送完成则开始建立连接。

>   为什么客户端和服务端要各自维护一个顺序号呢？

    1. 因为 TCP 是面向连接的稳定的协议，所以他需要知道对方有没有接收到，以此用加1来判断。
    2. 一旦对方接收到数据包的话，那么传回来顺序号一定加1，否则按连接失败处理。

>   为什么三次握手就可以了？

    1. 因为在服务端给出响应时（如标注1）做了两件事。
    2. 告诉客户端我接收到了你传来的 x，并且同时向客户端发送了一个顺序号，一次握手干了两件事，再多握一次就浪费了。      

### 四次挥手
1. 主动关闭方会先发送一个 FIN 并附带序列号，表示告诉被关闭方，我已经不会再给你发数据了，**但是此时主动关闭方还可以接受数据**。

2. 被关闭方收到 FIN 信号后，发送一个确认应答码（收到的序列号加1），告诉客户端你这个关闭连接的请求我收到了。

3. 被关闭方发送一个 FIN 并附带序列号，用来关闭 被关闭方到主动关闭方的数据传输，即告诉对方我不会再给发数据了。

4. 主动关闭方发送一个确认应答码（收到的序列号加1），至此完成四次挥手。

> 注意点：

    1. 发送 FIN 信号只是代表不能继续发送数据，但是可以接受数据。
    2. 在很多时候，TCP连接的断开都会由TCP层自动进行，例如CTRL+C终止程序，TCP连接依然会正常关闭。

> 为什么需要四次挥手？三次不行吗

    1. 因为在第二次和第三次之间必须要有一个空闲时间（如标注2）。服务端需要利用这个空闲时间去处理后事，去清除释放资源。
    2. 还有一点就是，被关闭方虽然收到了 FIN 通知，但是自己向对方发送的数据未必发完，所以需要再发一次 FIN，表示我的数据也都传完了，同意关闭连接。

>   第四次挥手后为什么要等待 2MSL 时间才能转换为 closed 状态?

    1. MSL 指的是一段报文的最大生存时间，2MSL也就是这个时间的2倍即2-4分钟，表示主动关闭的一方将继续等待2-4分钟。
    2. 首先网络是不可靠的，即不能保证最后一次 ACK 对方一定能收到，所以一旦收不到还需要继续发，在这个 2MSL 时间段内会重新发。
    3. 在一个，避免报文被混淆，就是说避免其他时候的连接被当成本次的连接。

### 滑动窗口机制
参考链接：[理解滑动窗口](https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-tcp-zhong-chuan-hua-dong-chuang-kou-liu-liang-kong-zhi-yong-sai-kong-zhi-fa-chou)

>   为什么要引入滑动窗口？

    1. TCP 建立连接成功后，开始传输数据，在这一过程中，每发送一次数据，都要等待确认应答，只有收到应答了才开始发下一段数据。
    2. 所以这种传输模式效率是比较低的，比如我收到你的数据了，但是我去做别的事了，一直没有应答你，那么你就需要一直等着。所以显然这是不合。
    3. 所以这种传输的缺点就是数据包往返时间越长，则效率越慢，所以才有了滑动窗口概念。

>   什么是窗口？什么是窗口大小？由谁来决定窗口大小？
    
    1. 窗口：实际上是指操作系统开辟的一个缓存空间，发送方在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。
    2. 窗口大小就是指：无需等待确认应答，而可以继续发送数据的最大值。
    3. 接收方来决定窗口大小。TCP 头里有一个字段叫 Window，这个字段是接收方告诉发送方我还能接受多少数据，于是发送端就可以根据这个接收端的处理能力来发送数据。  

假设窗口大小为 3 个 TCP 段，那么发送方就可以连续发送 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过下一个确认应答进行确认。如下图：

<img src='/img/http_2_12.png' width='400' style="margin-bottom: 10px" />

>   发送方的滑动窗口

    1. 如下图。通过三个标注的指针，划分四块区域 #1 #2 ...
    2. 仔细看黄色部分，如果发送方把数据都发完了，即可用窗口变为 0 了，那么就只能等待确认应答，才能继续向右移动滑动窗口。
    3. 绝对指针 1 指向的是已发送但未收到确认的第一个字节的序列号。绝对指针 2 指向的是未发送但在可发送范围的第一个字节的序列号。
    4. 为什么说 #4 区域那个是相对指针，因为他会被滑动窗口慢慢吞食掉，因为 #1 会不断增加（已发送且已确认）。就会使滑动窗口向右移动。
    
<img src='/img/http_2_13.png' width='550' style="margin-bottom: 10px" />    

>   接收方的滑动窗口

    1. 如下图。由两个指针划分三块区域。#3 接受窗口会不断向右移动直到数据全部接收完成。
    2. 接收窗口大小和发送窗口大小并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。
    3. 因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样接收窗口可以很快的就空缺出来。
       那么新的接收窗口大小是通过 TCP 报文中的 Windows 字段来告诉发送方。在这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

<img src='/img/http_2_14.png' width='550' style="margin-bottom: 10px" />

## cookie session 与 token
<img src='/img/http_1_3.png' width='400' />

1. cookie是文本内容，存在于客户端，随请求发送该url下的所有cookie到服务端。

2. session存在于服务端，通过唯一值sessionId来记录cookie，从而区分每一个用户，cookie随每一个连接请求发送到服务端。

3. 因为http协议是无状态的，所以单靠协议是无法维持会话机制的。一旦http断开连接后，服务器不知道来请求的是不是之前的客户端。所以为了安全必须要维持会话机制。

4. token类似于令牌，不是维持会话的，目的是增强安全性。在有cookie的同时用token做了双重保障。

## HTTP 协议演变

### HTTP 1.1
1. 使用纯文本格式传输。

2. 只对请求体和响应体通过gzip进行了压缩。

3. 开启了长连接，也是在一个tcp连接上发多个文件，但是是串行的（即必须前一个资源发送完毕才可发送下一个资源）。**容易造成阻塞**。

4. 浏览完为同一个域名最多维持6个TCP持久连接。

5. 如果不用https，默认传输是不会加密的。

6. **http1.x是单工模式**。即在向服务器发请求时，不允许服务器同时向客户端传输。

### HTTP 2

<img src='/img/http_1_4.png' width=400 />

1. 使用二进制格式传输，更高效和紧凑。例如传输一个较大的资源时，用二进制的优势就很明显。

2. 对请求报头和响应报头也进行了压缩。

3. 多路复用，一个http连接上可以并发多个资源文件。具体实现为将文件切块，交织着去发送。**解决了文件阻塞问题**。

4. 多路复用只是解决了文件阻塞的问题，**并没有解决队首阻塞**。队首阻塞指切块后某个块传输失败或缓慢，这样最后拼接的文件也是不全的。**所以http3解决了队首阻塞的问题**。

5. 服务器主动推送，减少请求延迟。如一个连接不断开，服务器有数据的话会主动推送到客户端。

6. 同一个域下，多个页面间的数据可以共享，就不需要每个页面都去请求一次。

7. 传输过程默认进行了加密。

8. **http2是双工模式**，即客户端在向服务器发请求时，同时允许服务器向客户端传输资源。

#### 二进制分帧层

    1. http2所有功能增强的核心是使用了二进制分帧层。
    
    2. http1.x中以换行回车符作为文本（文本指报头和报文）的分隔符，容易被攻击因为可以向里面插入换行等符号。
       而二进制分帧层通过计算偏移量（报头或报文的长度），例如报头的长度为100，协议会在报头前面加上100这个数字，这样就知道了这个报头从哪开始从哪结束，不用逐帧去扫描。

#### 伪头字段

    1. 二进制分帧后的产物。
    
    2. 请求头共有4个，:method :path :scheme :authority。对应着请求行中的信息。
    
    3. 响应头共有1个，:status 对应着状态码。

#### 多路复用

    1. 根本目的是提高传输性能和页面的渲染效率。因为串行的话，某个js css文件失败或传输太慢的话，会阻塞页面的渲染。
    
    2. http1.x如果想实现多个资源并行传输，需要开启多个tcp连接，并且每个连接上的资源是串行的。
    
    3. http2并行的实现是切割资源，多个资源分块并行发送。因为是二进制传输，切割和拼接都会很容易。

### HTTP 3

<img src='/img/http_1_5.png' width=400 />

1. 谷歌开发的全新的协议，颠覆了1和2的思想。现处于提案和测试阶段。

2. 解决了队首阻塞，如有丢包或包传输失败，我就先发下一个包，后来我在补救再重发。

3. QUIC不受网络切换（即ip）的影响，所以当你网断了或者切网时，它依然能够准确识别，因为他在处理UDP的数据包时，会在包中加上类似于客户端的识别码，就不需要再次重新建立连接。而http2是基于tcp的，tcp基于ip的。所以ip变了就需要重新建立tcp连接，这一过程是很慢的。

## 知识点随笔

### keep-alive长连接
1. 长连接指一旦建立tcp连接，则对该连接进行复用，而不是每次发请求都重新去建立。只有等所有的请求和响应接收完毕，再进行断开。

2. 可以节约资源，减少IO操作所带来的消耗。

3. http1.1才支持长连接。
