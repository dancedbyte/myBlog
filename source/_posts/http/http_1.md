---
title: HTTP 知识梳理
tags: HTTP
categories: 网络协议
date: 2020-10-04
index_img: /img/http_1_1.jpg
---

## HTTP 工作过程

1. 一次http操作称为一个事务，事务可以分步骤，且每个步骤必须全部操作成功才可认为这次事务成功。否则哪怕一个步骤出错则事务失败。

2. 以下过程，如某个步骤出错的话，错误信息将返回给客户端，即浏览器中见到的404、500等。

    1. 客户机与服务器建立tcp连接。因为http是基于tcp的，所以想建立http必须先建立tcp连接。**即三次握手**。
    
    2. 客户端发送请求，包括请求行、请求报头、请求体。
    
    3. 服务端处理请求后给出响应，包括响应行、响应报头、响应体。
    
    4. 客户端收到返回信息后浏览器开始渲染，并与服务器断开连接。即**四次挥手**。为什么要断开呢？因为一个tcp连接是一个IO操作，很耗资源的，用完之后要及时释放。

## 请求方法
GET：一般用于查询，请求参数在url中。

POST：一般用于添加，请求参数在请求体中。

PUT：修改资源，请求参数在url中。

DELETE：用于删除所标识的资源。

HEAD：让服务器只返回资源的**响应报头**。

TRACE：服务器回送收到的请求信息，一般用于**诊断或测试**。

OPTIONS：预请求，检查服务器的性能。当跨域或人为修改了content-type等请求头，浏览器会自动发起OPTIONS请求。

## HTTP 状态码
1xx：请求已接收，继续处理，可能是继续发送其他的请求。
    
    101：协议协商，服务端告诉客户端需要更换协议才可访问。

2xx：请求被成功的理解和接收。

3xx：重定向，要完成请求必须进行更进一步的操作。
    
    301：永久性移动，资源已经不在之前的地址了。
    302：临时移动。
    304：本地重定向，需要跳转到本地的缓存上。
    305：必须通过代理才能访问该资源。
    
4xx：客户端错误，如语法、请求参数等错误。

    400：错误的请求方式，参数或请求方法不对。
    401：身份验证，没有权限。
    403：服务器拒绝执行该请求。
    404：请求了错误的不存在的路径。
    408：请求时间过长，可能是数据包过大，一直在发的过程中，服务器一直在等待这个请求的过程。
    410：资源已经不存在了，和404的区别是404根本就没有，而410属于原来有现在没有了，服务器只维护资源的一些信息，资源实际不存在了。
    413：发送数据包过大，服务器处理不了。
    

5xx：服务端错误，服务器未能实现合法的响应。

    500：服务器内部错误，例如代码抛出异常。
    501：请求了服务器不支持的功能。
    502：网关错误，如出现502则请求的服务器一定是反向代理，代理服务器向后转发时，接收的服务器挂了。

## TCP/IP 协议栈

<img src='/img/http_1_1.jpg' width='400' />

1. 共有五层。应用层、传输层、网络层、数据链路层、物理层。

    ```
       应用层: 为用户提供所需服务，如http https dns等。               
       传输层：为应用层提供端对端的通信功能，保证数据包的顺序及完整性。
       网络层：解决主机到主机的通信问题，IP协议是网络层重要协议。为主机分配IP及维护IP状态。
       数据链路层：将传输层、网络层传下来的字节流转化成光电信号来让硬件承载。
       物理层：纯硬件，如网线水晶头等。
    ```

2. 只能层与层之间传输，不能跨层，分工明确。

3. **http, https, dns都属于应用层协议**。一般我们最多只能接触到传输层。

4. **传输层**提供 **TCP**传输控制协议 和 **UDP**用户数据报（http3是基于UDP协议）。
    
    ```
    TCP：面向链接的、非常稳定可靠的协议。可以理解为TCP像打电话，双方必须确认通话后，才可进行传输。所以要有三次握手四次挥手。
    UDP：无链接、不能保证数据一定被对方接收到。可以理解为对讲机，不确定对方是否接收到了。
    ```

5. IP协议是网络层重要协议。所说的 TCP/IP 协议其实就是传输层和网络层的协议。

## HTTP 在协议栈中的位置

<img src='/img/http_1_2.png' width='400' />

1. http默认端口80。https默认端口443。

2. SSL是TLS的前身，它属于一个模块嵌入到http协议中

## cookie session 与 token
<img src='/img/http_1_3.png' width='400' />

1. cookie是文本内容，存在于客户端，随请求发送该url下的所有cookie到服务端。

2. session存在于服务端，通过唯一值sessionId来记录cookie，从而区分每一个用户，cookie随每一个连接请求发送到服务端。

3. 因为http协议是无状态的，所以单靠协议是无法维持会话机制的。一旦http断开连接后，服务器不知道来请求的是不是之前的客户端。所以为了安全必须要维持会话机制。

4. token类似于令牌，不是维持会话的，目的是增强安全性。在有cookie的同时用token做了双重保障。
    
## 证书签发机构(CA)

### CA工作流程（浏览器如何验证证书有效性？）
1. 服务器 example.com（必须有域名）将从CA（如Digicert）请求TLS证书。

2. Digicert将为example.com创建证书，证书将包含必要的数据，如服务器名称， 服务器的公钥等。
 
3. Digicert将创建证书的哈希值，并使用自己的私钥对其进行加密。 

4. 浏览器和操作系统会内置Digicert等权威机构的公钥。

5. 当浏览器收到签名证书时，它将使用公钥（第3步中私钥对应的）从签名证书中生成哈希值，它还将使用证书中 指定的散列算法生成证书的散列（即哈希值），如果两个哈希值匹配，则签名验证成 功并且证书是可信的。

6. 现在浏览器可以使用证书中指定的example.com的公钥（这个公钥和第5步的公钥完全不是一回事，能走到第6步说明证书验证已经完事，这个共钥是后续在http请求所用到的）继续进行身份验证过程。

## HTTP 协议演变

### HTTP 1.1
1. 使用纯文本格式传输。

2. 只对请求体和响应体通过gzip进行了压缩。

3. 开启了长连接，也是在一个tcp连接上发多个文件，但是是串行的（即必须前一个资源发送完毕才可发送下一个资源）。**容易造成阻塞**。

4. 浏览完为同一个域名最多维持6个TCP持久连接。

5. 如果不用https，默认传输是不会加密的。

6. **http1.x是单工模式**。即在向服务器发请求时，不允许服务器同时向客户端传输。

### HTTP 2

<img src='/img/http_1_4.png' width=400 />

1. 使用二进制格式传输，更高效和紧凑。例如传输一个较大的资源时，用二进制的优势就很明显。

2. 对请求报头和响应报头也进行了压缩。

3. 多路复用，一个http连接上可以并发多个资源文件。具体实现为将文件切块，交织着去发送。**解决了文件阻塞问题**。

4. 多路复用只是解决了文件阻塞的问题，**并没有解决队首阻塞**。队首阻塞指切块后某个块传输失败或缓慢，这样最后拼接的文件也是不全的。**所以http3解决了队首阻塞的问题**。

5. 服务器主动推送，减少请求延迟。如一个连接不断开，服务器有数据的话会主动推送到客户端。

6. 同一个域下，多个页面间的数据可以共享，就不需要每个页面都去请求一次。

7. 传输过程默认进行了加密。

8. **http2是双工模式**，即客户端在向服务器发请求时，同时允许服务器向客户端传输资源。

#### 二进制分帧层

    1. http2所有功能增强的核心是使用了二进制分帧层。
    
    2. http1.x中以换行回车符作为文本（文本指报头和报文）的分隔符，容易被攻击因为可以向里面插入换行等符号。
       而二进制分帧层通过计算偏移量（报头或报文的长度），例如报头的长度为100，协议会在报头前面加上100这个数字，这样就知道了这个报头从哪开始从哪结束，不用逐帧去扫描。

#### 伪头字段

    1. 二进制分帧后的产物。
    
    2. 请求头共有4个，:method :path :scheme :authority。对应着请求行中的信息。
    
    3. 响应头共有1个，:status 对应着状态码。

#### 多路复用

    1. 根本目的是提高传输性能和页面的渲染效率。因为串行的话，某个js css文件失败或传输太慢的话，会阻塞页面的渲染。
    
    2. http1.x如果想实现多个资源并行传输，需要开启多个tcp连接，并且每个连接上的资源是串行的。
    
    3. http2并行的实现是切割资源，多个资源分块并行发送。因为是二进制传输，切割和拼接都会很容易。

### HTTP 3

<img src='/img/http_1_5.png' width=400 />

1. 谷歌开发的全新的协议，颠覆了1和2的思想。现处于提案和测试阶段。

2. 解决了队首阻塞，如有丢包或包传输失败，我就先发下一个包，后来我在补救再重发。

3. QUIC不受网络切换（即ip）的影响，所以当你网断了或者切网时，它依然能够准确识别，因为他在处理UDP的数据包时，会在包中加上类似于客户端的识别码，就不需要再次重新建立连接。而http2是基于tcp的，tcp基于ip的。所以ip变了就需要重新建立tcp连接，这一过程是很慢的。

## 密码学
1. 密码学的处理对象是数字和字符串。

2. 散列是一旦被转化为其他形式，则永远无法恢复的加密技术。

3. 加密

    ```
    对称加密：不安全。加解密用同一种算法（秘钥）。
    非对称加密：
        1. 分为公钥和私钥，相对安全。且总是成对出现。
        2. 如果用共钥进行加密，那么只能用私钥进行解密。调过来如果用私钥加密，只能用共钥才能解密。
        3. 因为加密和解密使用的两个不同的秘钥，所以叫非对称加密。
    非对称加密过程：
        1. A要向B发送信息，A和B都要产生一对用于加密和解密的公钥和私钥。
        2. A的私钥保密，A的公钥告诉B；B的私钥保密，B的公钥告诉A。
        3. A要给B发送信息时，A用B的公钥加密信息，因为A知道B的公钥。所以B收到的消息是用B的共钥加密后的消息。
        4. B收到这个消息后，B用自己的私钥解密A传过来的消息。其他所有收到这个报文的人都无法解密，因为只有B才有B的私钥。
    ```

4. 秘钥交换算法，增加被破解的难度，增加想要破解所消耗的时间。支撑https协议。

    ```
    Diffie-Hellman是一种著名的密钥协商算法，在交换公钥过程中会用到。
    1. Alice与Bob确定两个大素数n和g，这两个数不用保密。
    2. Alice选择另一个大随机数x（需保密，只能有自己知道），计算余数A：A = gx mod n
    3. Alice将A发给Bob 
    4. Bob选择另一个大随机数y（需保密，只能有自己知道），计算余数B：B = gy mod n
    5. Bob将B发给Alice
    6. 计算秘密密钥K1如下:K1 = Bx mod n
    7. 计算秘密密钥K2如下:K2 = Ay mod n 
    8. 若K1 = K2，因此Alice和Bob可以用其进行加解密
    ```


## 知识点随笔

#### keep-alive长连接
1. 长连接指一旦建立tcp连接，则对该连接进行复用，而不是每次发请求都重新去建立。只有等所有的请求和响应接收完毕，再进行断开。

2. 可以节约资源，减少IO操作所带来的消耗。

3. http1.1才支持长连接。
