---
title: 彻底弄懂浏览器运行机制
tags: 浏览器
categories: 浏览器
date: 2020-10-06
index_img: /img/http_2_1.jpg
---

# 浏览器运行机制

## 进程和线程
<img src='http://note.youdao.com/yws/res/9972/WEBRESOURCE4ccd5177df4509b112c0d23c1ffb688c' width=450 />

1. 进程是资源分配的最小单位，线程是程序执行的最小单位。

2. **进程**有自己独立的空间地址，每启动一个进程，系统就会为进程分配空间，所以进程是很昂贵的。

3. **线程**是共享进程中数据的，使用相同的空间地址，所以CPU创建线程、切换线程的开销比进程要小很多。

4. 同一进程下的线程能共享全局变量、静态变量等数据。而进程间通信需要依赖IPC（通信方式）。

5. **但是多进程的程序更加健壮**。多线程程序如果有一个线程断了，则整个程序就挂了。多进程程序的话则不会，**因为每个进程都有一个独立的空间地址**。

## 输入url到浏览器发生了什么？
<img src='http://note.youdao.com/yws/res/10640/WEBRESOURCEa879bd1f9c5d2b13521ae2fc37bbbc1c' width=600 />

### 整体流程
1. 浏览器进程、网络进程、渲染进程（渲染主线程、合成线程、IO线程等）。

2. 浏览器进程将真正的url发给网络进程，网络进程发起真的请求，并解析响应数据返回给浏览器进程。

3. 浏览器进程收到响应数据后，发一个消息通知渲染进程，渲染进程接收到消息后便开始准备接收html等数据，方式是与**网络进程建立连接通道**。

4. 渲染进程准备好后会发送一个确认的消息给浏览器进程，表示我已经建立好连接通道，可以解析页面数据了。浏览器进程收到确认后便开始释放旧的文档，然后更新浏览器进程中页面的状态。

### 网络进程
1. 检查网络连通性，当跨过了内网和外网的设备后，说明网络是通的。linux或mac可以通过traceroute命令查看本地到目标服务器之前的设备。

2. 构建请求行。

    ```js
    // 请求方法是GET，路径为根路径，HTTP协议版本为1.1
    GET / HTTP/1.1
    ```
3. 查找强缓存，具体可参考 [http协议详解](https://note.youdao.com/)。    

4. DNS解析。输入的url是字符串，机器不能识别，去dns服务器（相当于大的数据库）里查出来对应的ip，一个ip可以对应一个机房，里面有好多服务器，可以通过nginx反向代理的手段转发到不同的服务器上。

5. 建立 TCP 连接，**具体可参考下文**。

6. 正式发送http请求，服务端并给出响应。 响应和请求未必走同一条路径，网络是网状结构的，从区域网到目标服务器会有好多透明的路由器，透明即我们是看不见的，每个路由器都有一个自己的路由表，当想要发数据时会先去查自身的路由表，并指明下一站。数据包每走一个路由在网络上叫一跳

### 渲染进程

1. **构建dom树**。浏览器不能解析html，需要将html转化为浏览器能认识的dom树。

2. **样式计算，生成渲染树**。将css文本转化为浏览器能认识的styleSheets，并将css标准化（转化em、将color转化成rgb等），最后计算出dom树中每个节点的具体样式。

3. **布局阶段，生成布局树**。有了dom树及dom树的样式，现需要计算出具体的几何位置。

4. **分层、绘制列表**。渲染引擎需要为特定节点生成图层，并生成一棵对应的图层树。不是布局树中的每个节点都有对应的图层，如果该节点没有图层，则该节点从属于父图层。绘制列表（记录执行的命令和顺序）。

    > 哪些元素会生成层？哪些层GPU会参与加速？
    
    ```js
    1. 根元素、position、transform、css滤镜、半透明、canvas、video、overflow
    2. css3D、transform、video。所以我们可以用transform代替position来做一些动画，以减少重排重绘。
    3. transform会使GPU跳过绘制和布局阶段。
    ```

5. **分块、栅格化**。有了绘制列表中的指令，真正执行绘制操作是由渲染引擎中的合成线程来完成。合成线程将图层分块并栅格化成位图。

6. **合成及显示**。当所有图层被栅格化后，合成线程会生成一个开始绘制的命令并告诉浏览器进程。浏览器进程中有一个叫viz的组件用来接收命令。最后根据命令将页面绘制到内存中，最后显示到屏幕上。

## 重要知识点分析
深刻理解 DNS解析、建立TCP连接到底是怎么回事！

### DNS 解析
看图就行。

<img src='http://note.youdao.com/yws/res/10483/WEBRESOURCE58c8cf8667008b24e0845d8c4158cba3' width=700 />

### 建立 TCP 连接
SYN: 发起连接

seq: 顺序号

ACK: 确认应答

FIN: 关闭连接

<img src='http://note.youdao.com/yws/res/10550/WEBRESOURCEbdfa59edf73df5b3af8e2d0de645ad33' width=400 />


#### 三次握手

>   为什么客户端和服务端要各自维护一个顺序号呢？

    1. 因为 TCP 是面向连接的稳定的协议，所以他需要知道对方有没有接收到，以此用加1来判断。
    2. 一旦对方接收到数据包的话，那么传回来顺序号一定加1，否则按连接失败处理。

>   为什么三次握手就可以了？

    1. 因为在服务端给出响应时（如标注1）做了两件事。
    2. 告诉客户端我接收到了你传来的 x，并且同时向客户端发送了一个顺序号。
    3. 一次握手干了两件事，再多握一次就浪费了。

1. 客户端发起连接，并向服务端发送一个顺序号(x)，这个x是由客户端自己维护的。

2. 服务端接收到客户端的x之后，给加1并返回给客户端，同时也要发送一个顺序号(y)给客户端，这个y是由服务端自己维护的。

3. 客户端接收到y之后，给加1再传回给服务端作为应答码。

#### 四次挥手

> 为什么需要四次挥手？三次不行吗

    1. 因为在第二次和第三次之间必须要有一个空闲时间（如标注2）。
    2. 服务端需要利用这个空闲时间去处理后事，去清除释放资源。
    3. 所以服务器不能讲二三两个动作合成一个

1. 客户端发送顺序号及确认应答码。

2. 服务端发送确认应答码，告诉客户端你这个关闭连接的请求我收到了。

3. 服务端在发送一个顺序号给客户端。

4. 客户端接收到顺序号之后加1在传给服务端。

## 浏览器缓存机制

<img src='http://note.youdao.com/yws/res/9254/WEBRESOURCE2bd43da917e8aa3280115063cd52c50d' width='400' />

>   为什么要有缓存机制？
    
    1. 服务器数据做持久化，则需要将数据存储到硬盘上，每次从硬盘上读数据是IO操作，很耗性能。
    2. 客户端向服务器发请求也是IO操作，这一过程建立连接等也是很耗资源的。
    3. 所以可以把访问比较频繁的资源在客户端这边做缓存。

> 缓存的优点？

    1. 减少冗余数据的传输。
    2. 减少服务器负担。
    3. 加快客户端加载网页的速度。

> 如何决定缓存标签是用 last-Modified 还是 Etag ？
    
    1. nginx等服务器进行设定。
    
> 什么时候不能用缓存策略 ？
    
    1. 数据经常变的比如接口响应。
    2. 认证信息绝对不能缓存。
    3. post请求是不能缓存的，因为post请求的参数不会保存到浏览器历史记录中。

### 整体流程
1. 用户输入url，第一次本地肯定是没有缓存的，则正常发起请求，浏览器接收到响应后进行缓存。

2. 第一次请求时，服务器会将资源的最后修改时间last-Modified或Etag标识返回给客户端。**协商缓存时会用**。

3. 浏览器在后续请求时，如再次请求相同资源时，浏览器会先去缓存中查找该资源的响应header信息，根据header中的Cache-Control和Expires来判断该资源是否过期，如果没过期则直接使用，**不再向下进行**。**这是强缓存**。

4. 如果该资源的强缓存失效或该资源根本就不允许强缓存，则需要发送http请求，将if-Modified-Since和if-None-Match字段及对应值放到请求头中。

5. 这时由服务器决策，如果if-Modified-Since或if-None-Match的值变了，要重新给出响应。否则通知浏览器（304）从自己的缓存中读取。这是**缓存协商**。

6. 如果服务器发现协商缓存失效了，会重新给出响应。那么浏览器会拿到新的指纹（Etag或last-Modified）。则浏览器会更新该资源的指纹并放到缓存中。


### 强缓存
1. 通过http响应头中Cache-Control和Expires两个字段来控制，表示资源的缓存时间。在这个缓存时间内，下次请求该资源时则直接使用缓存，否则发送http请求进行协商缓存。

2. 强缓存中，普通刷新不会清除它，需要强制刷新才行。强制刷新时请求头会带上Cache-Control:no-cache。

#### Expires
Expires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。

由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。
```js
// 当两者同时存在时，cache-control优先级更高。
cache-control:max-age=691200
expires:Fri, 14 Apr 2017 10:47:02 GMT
```

#### Cache-Control
Cache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间。
```js
max-age：资源的相对有效时间，是个时间戳。

no-cache：不使用本地缓存。需要使用协商缓存，然后走协商缓存那套逻辑。

no-store：直接禁止浏览器缓存数据，每次都向服务器请求新的资源。

public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

private：只能被终端用户的浏览器缓存，不允许CDN等中间缓存服务器对其缓存。
```

### 协商缓存
1. 由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。

2. 当协商缓存命中时，即返回304时，服务器不会返回资源内容。

3. Etag 和 If-None-Match、Last-Modified 和 If-Modify-Since。

### Etag 相比 Last-Modified 的优势在哪
1. 当不小心执行linux的touch命令，这个命令本质并不会去改变文件内容，但是他的最后修改时间还是会变，所以这时用Last-Modified的话，缓存就失效了。

2. 某些文件修改非常频繁，比方说1s内修改了N次，但Last-Modified能检测到的粒度是秒级的，那么这种修改则无法准确判断。

3. 某些服务器不能精确的得到文件的最后修改时间。

## 浏览器中的缓存位置
当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源，那么浏览器中这些资源缓存在哪呢？

1. Service Worker 离线缓存

    ```
    1. Service Worker 让 JS 运行在主线程之外，是一个后台运行的独立线程，可以在代码中启用。
    ```
   
    ```js
    // index.js
    if ('serviceWorker' in navigator) {
           navigator.serviceWorker.register('./sw.js').then(function () {
               // 注册成功
           });
    }
    ```
   
    ```js
    // sw.js 请求拦截
    self.addEventListener('fetch', function (e) {
           // 如果有cache则直接返回，否则通过fetch请求
           e.respondWith(
               caches.match(e.request).then(function (cache) {
                   return cache || fetch(e.request);
               }).catch(function (err) {
                   console.log(err);
                   return fetch(e.request);
               })
           );
    });   
    ```

2. Memory Cache 内存缓存

    ```
    1. 浏览器层面帮我们做的缓存，打开network可以看见有些请求的size字段会有 Memory Cache 字样。
    2. 效率上讲它是最快的，但存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。
    3. 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存。
    ```
3. Disk Cache 磁盘缓存

    ```
    1. 存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。
    2. 内存使用率比较高的时候，文件优先进入磁盘。
    ```

## 渲染引擎结构与工作流程
<img src='http://note.youdao.com/yws/res/10595/WEBRESOURCEffe12ad5a73e72571009dbe45678e04f' width=550 />

1. DOM树是至关重要的，一旦操作了dom树就会导致重新去生成渲染树和布局树。

2. 可以看出DOM Tree 和 Javascript Interpreter 是互相影响的，因为js可以操作dom，**并且一旦操作就会导致整个渲染流程停止**。所以一定要尽量少的去操作dom。

3. 在老版本浏览器中，每开一个tab页就需要建立一套浏览器进程、渲染进程、插件进程等。在现代浏览器中复用了浏览器进程和插件进程。**只需要建立一个渲染进程即可**，大大提升了效率。好处就是当一个tab页崩了不会影响其他**非同域**页面。

## V8(chrome JS解释引擎) 如何执行一段js代码
<img src='http://note.youdao.com/yws/res/9941/WEBRESOURCEb742acfd68945fa8a347f9fdfee4bffe' width=550 />

1. **将最初的源代码转化为抽象语法树(AST)，并生成执行上下文**。AST是一种重要的数据结构，Babel就是应用了AST这种数据结构，es6 -> es6 AST -> es5 AST -> js源代码

    ```
    第一阶段：分词 即词法分析
    第二阶段：解析 即语法分析
    ```

2. **生成字节码**。解释器 Ignition 根据 AST 生成字节码，并且字节码需要通过解释器转换成机器码才能执行。**所以解释器的作用是生成并转换字节码**。

3. **执行代码**。解释器在转换AST字节码时，如果发现一段代码被重复执行好多次，被称为热点代码，那么后台编译器会将这种热点代码直接编译为高效的机器码。然后当再次执行这段代码时，则会直接去执行机器码，大大提升了执行效率。

4. 字节码 + 解释器 + 编译器。 被称为**即时编译**。

## 消息队列 事件循环
<img src='http://note.youdao.com/yws/res/9969/WEBRESOURCEb37f2c56733bd9d6d6cb29cacf8cf42d' width=550 />

>   页面使用单线程的缺点？
    
    页面中所有执行的任务都来自于消息队列，所以只能等前一个任务执行完成后才可执行下一个。
    
>   如何处理优先级高的任务？

    1. 消息队列中的任务都属于宏任务，每个宏任务会维持一个微任务队列。
    2. 在执行宏任务过程中，如果有dom发生变化，则会将该任务添加到微任务队列中。
    3. 当想执行下一个宏任务时，都先去检查一下当前的微任务队列。这样就不会影响宏任务执行顺序和效率。

1. 如果想在线程运行过程中，既能接收新的任务又要去执行，就要采用事件循环。

2. 消息队列先进先出，尾部添加事件，头部取事件。

3. 消息队列：js执行、解析dom、样式计算、定时器、微任务、文件读写、表单输入等事件。
