---
title: 彻底弄懂浏览器运行机制
tags: 浏览器
categories: 浏览器
date: 2020-10-06
index_img: /img/http_2_1.jpg
---

# 浏览器运行机制

## 进程和线程
<img src='/img/http_2_2.png' width=400 />

1. 进程是资源分配的最小单位，线程是程序执行的最小单位。

2. **进程**有自己独立的空间地址，每启动一个进程，系统就会为进程分配空间，所以进程是很昂贵的。

3. **线程**是共享进程中数据的，使用相同的空间地址，所以CPU创建线程、切换线程的开销比进程要小很多。

4. 同一进程下的线程能共享全局变量、静态变量等数据。而进程间通信需要依赖IPC（通信方式）。

5. **但是多进程的程序更加健壮**。多线程程序如果有一个线程断了，则整个程序就挂了。多进程程序的话则不会，**因为每个进程都有一个独立的空间地址**。

## 输入url到浏览器发生了什么？
<img src='/img/http_2_3.png' width=600 />

### 整体流程
1. 浏览器进程、网络进程、渲染进程（渲染主线程、合成线程、IO线程等）。可以理解是这三个进程间相互协作来完成。

2. 浏览器进程将真正的url发给网络进程，网络进程发起真的请求，并解析响应数据返回给浏览器进程。

3. 浏览器进程收到响应数据后，发一个消息通知渲染进程，渲染进程接收到消息后便开始准备接收html等数据，方式是与**网络进程建立连接通道**。

4. 渲染进程准备好后会发送一个确认的消息给浏览器进程，表示我已经建立好连接通道，可以解析页面数据了。浏览器进程收到确认后便开始释放旧的文档，然后更新浏览器进程中页面的状态。

### 网络进程
1. 检查网络连通性，当跨过了内网和外网的设备后，说明网络是通的。linux或mac可以通过traceroute命令查看本地到目标服务器之前的设备。

2. 构建请求行。

    ```js
    // 请求方法是GET，路径为根路径，HTTP协议版本为1.1
    GET / HTTP/1.1
    ```
3. 查找强缓存，下面会讲强缓存。    

4. DNS解析。输入的url是字符串，机器不能识别，去dns服务器（相当于大的数据库）里查出来对应的ip，一个ip可以对应一个机房，里面有好多服务器，可以通过nginx反向代理的手段转发到不同的服务器上。

5. 建立 TCP 连接，**具体可参考下文**。

6. 正式发送http请求，服务端并给出响应。 响应和请求未必走同一条路径，网络是网状结构的，从区域网到目标服务器会有好多透明的路由器，透明即我们是看不见的，每个路由器都有一个自己的路由表，当想要发数据时会先去查自身的路由表，并指明下一站。数据包每走一个路由在网络上叫一跳

### 渲染进程

1. **构建dom树**。浏览器不能解析html，需要将html转化为浏览器能认识的dom树。

2. **样式计算，生成渲染树**。将css文本转化为浏览器能认识的styleSheets，并将css标准化（转化em、将color转化成rgb等），最后计算出dom树中每个节点的具体样式。

3. **布局阶段，生成布局树**。有了dom树及dom树的样式，现需要计算出具体的几何位置。

4. **分层、绘制列表**。渲染引擎需要为特定节点生成图层，并生成一棵对应的图层树。不是布局树中的每个节点都有对应的图层，如果该节点没有图层，则该节点从属于父图层。绘制列表（记录执行的命令和顺序）。

> 哪些元素会生成层？哪些层GPU会参与加速？
    
```
1. 根元素、position、transform、css滤镜、半透明、canvas、video、overflow
2. css3D、transform、video。所以我们可以用transform代替position来做一些动画，以减少重排重绘。
3. transform会生成一个全新的层，这样该层上的所有重绘操作不会影响别的层。
```

5. **分块、栅格化**。有了绘制列表中的指令，真正执行绘制操作是由渲染引擎中的合成线程来完成。合成线程将图层分块并栅格化成位图。

6. **合成及显示**。当所有图层被栅格化后，合成线程会生成一个开始绘制的命令并告诉浏览器进程。浏览器进程中有一个叫viz的组件用来接收命令。最后根据命令将页面绘制到内存中，最后显示到屏幕上。

## 重要知识点分析
深刻理解 DNS解析、建立TCP连接到底是怎么回事！

### DNS 解析
DNS 是一个域名名字系统，用来存储域名与 Ip 的对应关系。通俗来说就是一个键值对的列表。接下来说 DNS 解析的具体流程！

1. **先检查本地 hosts 文件**，这个文件是没有拓展名的系统文件，可以在里面配置一些域名与 Ip 的对应关系。这样当我们在浏览器输入一个配置好的域名，则直接从本地 hosts 文件中取。
    
    这样做的好处显而易见就是加快域名解析，不用再去域名系统解析。还有一个用处是可以屏蔽垃圾网站，即将垃圾网站的域名指向一个错误的 Ip。
    
    该文件在 Mac 系统下的目录是： ~/private/etc

2. 如果 hosts 文件没有找到相应配置，则继续检查**本地 DNS 缓存**。mac 下可通过 nslookup 命令查看本地 DNS 解析记录。如下是我本地对某域名的缓存记录 47.94.174.112。

   <img src='/img/http_2_10.png' width=500 />  

3. 如果前两个走不通或者我们是第一次访问一个域名，那么就要**开始访问 DNS 服务器了。DNS 服务器也有自己的缓存，会先在缓存里查找**，如果有的话直接返回。当我们电脑连接网络后，可以查看对应的 DNS 服务器地址。

    点击 系统偏好设置 - 网络 - 高级。则可以看到自己网络对应 DNS 服务器地址。
    
    <img src='/img/http_2_11.png' width=400 />

4. 如果 DNS 缓存没有找到，则**开始 DNS 服务器递归查找**。以访问 www.ghmwin.com 为例。

    ① 询问根域名服务器（下图标注3），获取顶级域名 .com 对应的ip地址
    ② 询问顶级域名服务器（下图标注4），获取二级域名 .ghmwin.com 对应的ip地址
    ③ 询问二级域名服务器（下图标注5），获取三级域名 www.ghmwin.com 对应的ip地址
    ④ 域名解析完成后，DNS 服务器拿到完整的 Ip 地址。DNS 服务器会做一层缓存。
    ⑤ DNS 服务器将最终 Ip 返回给用户，用户拿到后并缓存。

    <img src='/img/http_2_4.png' width=600 />
    
### 建立 TCP 连接

<img src='/img/http_2_5.png' width=400 />

#### 常用标志位
SYN: 发起连接； seq: 顺序号； ACK: 确认应答； FIN: 关闭连接

#### 三次握手
握手过程中传送的包里**不包含数据**，三次握手完毕后，客户端与服务器才**正式开始传送数据**。理想状态下，TCP 连接一旦建立，只要通信双方不主动关闭连接，则 TCP 连接都将被一直保持下去。

1. 客户端发起连接，并向服务端发送一个顺序号(x)，这个 x 是由客户端自己维护的。

2. 服务端接收到客户端的 x 之后，给加 1 并返回给客户端，同时也要发送一个顺序号(y)给客户端，即 SYN + ACK 包， 这个 y 是由服务端自己维护的。

3. 客户端接收到 y 之后，给加 1 再传回给服务端作为应答码。此包发送完成则开始建立连接。

>   为什么客户端和服务端要各自维护一个顺序号呢？

    1. 因为 TCP 是面向连接的稳定的协议，所以他需要知道对方有没有接收到，以此用加1来判断。
    2. 一旦对方接收到数据包的话，那么传回来顺序号一定加1，否则按连接失败处理。

>   为什么三次握手就可以了？

    1. 因为在服务端给出响应时（如标注1）做了两件事。
    2. 告诉客户端我接收到了你传来的 x，并且同时向客户端发送了一个顺序号，一次握手干了两件事，再多握一次就浪费了。      

#### 四次挥手
1. 主动关闭方会先发送一个 FIN 并附带序列号，表示告诉被关闭方，我已经不会再给你发数据了，**但是此时主动关闭方还可以接受数据**。

2. 被关闭方收到 FIN 信号后，发送一个确认应答码（收到的序列号加1），告诉客户端你这个关闭连接的请求我收到了。

3. 被关闭方发送一个 FIN 并附带序列号，用来关闭 被关闭方到主动关闭方的数据传输，即告诉对方我不会再给发数据了。

4. 主动关闭方发送一个确认应答码（收到的序列号加1），至此完成四次挥手。

> 注意点：

    1. 发送 FIN 信号只是代表不能继续发送数据，但是可以接受数据。
    2. 在很多时候，TCP连接的断开都会由TCP层自动进行，例如CTRL+C终止程序，TCP连接依然会正常关闭。

> 为什么需要四次挥手？三次不行吗

    1. 因为在第二次和第三次之间必须要有一个空闲时间（如标注2）。服务端需要利用这个空闲时间去处理后事，去清除释放资源。
    2. 还有一点就是，被关闭方虽然收到了 FIN 通知，但是自己向对方发送的数据未必发完，所以需要再发一次 FIN，表示我的数据也都传完了，同意关闭连接。

>   第四次挥手后为什么要等待 2MSL 时间才能转换为 closed 状态?

    1. MSL 指的是一段报文的最大生存时间，2MSL也就是这个时间的2倍即2-4分钟，表示主动关闭的一方将继续等待2-4分钟。
    2. 首先网络是不可靠的，即不能保证最后一次 ACK 对方一定能收到，所以一旦收不到还需要继续发，在这个 2MSL 时间段内会重新发。
    3. 在一个，避免报文被混淆，就是说避免其他时候的连接被当成本次的连接。

#### 滑动窗口机制
参考链接：[理解滑动窗口](https://labuladong.gitbook.io/algo/labuladong-he-ta-de-peng-you-men/30-zhang-tu-jie-tcp-zhong-chuan-hua-dong-chuang-kou-liu-liang-kong-zhi-yong-sai-kong-zhi-fa-chou)

>   为什么要引入滑动窗口？

    1. TCP 建立连接成功后，开始传输数据，在这一过程中，每发送一次数据，都要等待确认应答，只有收到应答了才开始发下一段数据。
    2. 所以这种传输模式效率是比较低的，比如我收到你的数据了，但是我去做别的事了，一直没有应答你，那么你就需要一直等着。所以显然这是不合。
    3. 所以这种传输的缺点就是数据包往返时间越长，则效率越慢，所以才有了滑动窗口概念。

>   什么是窗口？什么是窗口大小？由谁来决定窗口大小？
    
    1. 窗口：实际上是指操作系统开辟的一个缓存空间，发送方在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。
    2. 窗口大小就是指：无需等待确认应答，而可以继续发送数据的最大值。
    3. 接收方来决定窗口大小。TCP 头里有一个字段叫 Window，这个字段是接收方告诉发送方我还能接受多少数据，于是发送端就可以根据这个接收端的处理能力来发送数据。  

假设窗口大小为 3 个 TCP 段，那么发送方就可以连续发送 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过下一个确认应答进行确认。如下图：

<img src='/img/http_2_12.png' width='400' style="margin-bottom: 10px" />

>   发送方的滑动窗口

    1. 如下图。通过三个标注的指针，划分四块区域 #1 #2 ...
    2. 仔细看黄色部分，如果发送方把数据都发完了，即可用窗口变为 0 了，那么就只能等待确认应答，才能继续向右移动滑动窗口。
    3. 绝对指针 1 指向的是已发送但未收到确认的第一个字节的序列号。绝对指针 2 指向的是未发送但在可发送范围的第一个字节的序列号。
    4. 为什么说 #4 区域那个是相对指针，因为他会被滑动窗口慢慢吞食掉，因为 #1 会不断增加（已发送且已确认）。就会使滑动窗口向右移动。
    
<img src='/img/http_2_13.png' width='550' style="margin-bottom: 10px" />    

>   接收方的滑动窗口

    1. 如下图。由两个指针划分三块区域。#3 接受窗口会不断向右移动直到数据全部接收完成。
    2. 接收窗口大小和发送窗口大小并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。
    3. 因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样接收窗口可以很快的就空缺出来。
       那么新的接收窗口大小是通过 TCP 报文中的 Windows 字段来告诉发送方。在这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。

<img src='/img/http_2_14.png' width='550' style="margin-bottom: 10px" />
        
## 浏览器缓存机制

<img src='/img/http_2_6.png' width='400' />

>   为什么要有缓存机制？
    
    1. 服务器数据做持久化，则需要将数据存储到硬盘上，每次从硬盘上读数据是IO操作，很耗性能。
    2. 客户端向服务器发请求也是IO操作，这一过程建立连接等也是很耗资源的。
    3. 所以可以把访问比较频繁的资源在客户端这边做缓存。

> 缓存的优点？

    1. 减少冗余数据的传输。
    2. 减少服务器负担。
    3. 加快客户端加载网页的速度。

> 如何决定缓存标签是用 last-Modified 还是 Etag ？
    
    1. nginx等服务器进行设定。
    
> 什么时候不能用缓存策略 ？
    
    1. 数据经常变的比如接口响应。
    2. 认证信息绝对不能缓存。
    3. post请求是不能缓存的，因为post请求的参数不会保存到浏览器历史记录中。

### 整体流程
1. 用户输入url，第一次本地肯定是没有缓存的，则正常发起请求，浏览器接收到响应后进行缓存。

2. 第一次请求时，服务器会将资源的最后修改时间last-Modified或Etag标识返回给客户端。**协商缓存时会用**。

3. 浏览器在后续请求时，如再次请求相同资源时，浏览器会先去缓存中查找该资源的响应header信息，根据header中的Cache-Control和Expires来判断该资源是否过期，如果没过期则直接使用，**不再向下进行**。**这是强缓存**。

4. 如果该资源的强缓存失效或该资源根本就不允许强缓存，则需要发送http请求，将if-Modified-Since和if-None-Match字段及对应值放到请求头中。

5. 这时由服务器决策，如果if-Modified-Since或if-None-Match的值变了，要重新给出响应。否则通知浏览器（304）从自己的缓存中读取。这是**缓存协商**。

6. 如果服务器发现协商缓存失效了，会重新给出响应。那么浏览器会拿到新的指纹（Etag或last-Modified）。则浏览器会更新该资源的指纹并放到缓存中。


### 强缓存
1. 通过http响应头中Cache-Control和Expires两个字段来控制，表示资源的缓存时间。在这个缓存时间内，下次请求该资源时则直接使用缓存，否则发送http请求进行协商缓存。

2. 强缓存中，普通刷新不会清除它，需要强制刷新才行。强制刷新时请求头会带上Cache-Control:no-cache。

#### Expires
Expires是http1.0的规范，它的值是一个绝对时间的GMT格式的时间字符串。

由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。
```js
// 当两者同时存在时，cache-control优先级更高。
cache-control:max-age=691200
expires:Fri, 14 Apr 2017 10:47:02 GMT
```

#### Cache-Control
Cache-Control是在http1.1中出现的，主要是利用该字段的max-age值来进行判断，它是一个相对时间。
```js
max-age：资源的相对有效时间，是个时间戳。

no-cache：不使用本地缓存。需要使用协商缓存，然后走协商缓存那套逻辑。

no-store：直接禁止浏览器缓存数据，每次都向服务器请求新的资源。

public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

private：只能被终端用户的浏览器缓存，不允许CDN等中间缓存服务器对其缓存。
```

### 协商缓存
1. 由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。

2. 当协商缓存命中时，即返回304时，服务器不会返回资源内容。

3. Etag 和 If-None-Match、Last-Modified 和 If-Modify-Since。

### Etag 相比 Last-Modified 的优势在哪
1. 当不小心执行linux的touch命令，这个命令本质并不会去改变文件内容，但是他的最后修改时间还是会变，所以这时用Last-Modified的话，缓存就失效了。

2. 某些文件修改非常频繁，比方说1s内修改了N次，但Last-Modified能检测到的粒度是秒级的，那么这种修改则无法准确判断。

3. 某些服务器不能精确的得到文件的最后修改时间。

## 浏览器中的缓存位置
当强缓存命中或者协商缓存中服务器返回304的时候，我们直接从缓存中获取资源，那么浏览器中这些资源缓存在哪呢？

1. Service Worker 离线缓存 [详细介绍](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API)

    ```
    1. Service Worker 让 JS 运行在主线程之外，是一个后台运行的独立线程，可以在代码中启用。
    ```
   
    ```js
    // index.js
    if ('serviceWorker' in navigator) {
           navigator.serviceWorker.register('./sw.js').then(function () {
               // 注册成功
           });
    }
    ```
   
    ```js
    // sw.js 请求拦截
    self.addEventListener('fetch', function (e) {
           // 如果有cache则直接返回，否则通过fetch请求
           e.respondWith(
               caches.match(e.request).then(function (cache) {
                   return cache || fetch(e.request);
               }).catch(function (err) {
                   console.log(err);
                   return fetch(e.request);
               })
           );
    });   
    ```

2. Memory Cache 内存缓存

    ```
    1. 浏览器层面帮我们做的缓存，打开network可以看见有些请求的size字段会有 Memory Cache 字样。
    2. 效率上讲它是最快的，但存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。
    3. 比较大的JS、CSS文件会直接被丢进磁盘，反之丢进内存。
    ```
3. Disk Cache 磁盘缓存

    ```
    1. 一般当资源命中强缓存时，会直接去硬盘缓存中取。
    2. 存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。
    3. 内存使用率比较高的时候，文件优先进入磁盘。
    ```

## 渲染引擎结构与工作流程
<img src='/img/http_2_7.png' width=550 />

1. DOM树是至关重要的，一旦操作了dom树就会导致重新去生成渲染树和布局树。

2. 可以看出DOM Tree 和 Javascript Interpreter 是互相影响的，因为js可以操作dom，**并且一旦操作就会导致整个渲染流程停止**。所以一定要尽量少的去操作dom。

3. 在老版本浏览器中，每开一个tab页就需要建立一套浏览器进程、渲染进程、插件进程等。在现代浏览器中复用了浏览器进程和插件进程。**只需要建立一个渲染进程即可**，大大提升了效率。好处就是当一个tab页崩了不会影响其他**非同域**页面。

## V8(chrome JS解释引擎) 如何执行一段js代码
<img src='/img/http_2_8.png' width=550 />

1. **将最初的源代码转化为抽象语法树(AST)，并生成执行上下文**。AST是一种重要的数据结构，Babel就是应用了AST这种数据结构，es6 -> es6 AST -> es5 AST -> js源代码

    ```
    第一阶段：分词 即词法分析
    第二阶段：解析 即语法分析
    ```

2. **生成字节码**。解释器 Ignition 根据 AST 生成字节码，并且字节码需要通过解释器转换成机器码才能执行。**所以解释器的作用是生成并转换字节码**。

3. **执行代码**。解释器在转换AST字节码时，如果发现一段代码被重复执行好多次，被称为热点代码，那么后台编译器会将这种热点代码直接编译为高效的机器码。然后当再次执行这段代码时，则会直接去执行机器码，大大提升了执行效率。

4. 字节码 + 解释器 + 编译器。 被称为**即时编译**。

## 消息队列 事件循环
<img src='/img/http_2_9.png' width=550 />

>   页面使用单线程的缺点？
    
    页面中所有执行的任务都来自于消息队列，所以只能等前一个任务执行完成后才可执行下一个。
    
>   如何处理优先级高的任务？

    1. 消息队列中的任务都属于宏任务，每个宏任务会维持一个微任务队列。
    2. 在执行宏任务过程中，如果有dom发生变化，则会将该任务添加到微任务队列中。
    3. 当想执行下一个宏任务时，都先去检查一下当前的微任务队列。这样就不会影响宏任务执行顺序和效率。

1. 如果想在线程运行过程中，既能接收新的任务又要去执行，就要采用事件循环。

2. 消息队列先进先出，尾部添加事件，头部取事件。

3. 消息队列：js执行、解析dom、样式计算、定时器、微任务、文件读写、表单输入等事件。
