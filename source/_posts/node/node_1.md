---
title: node 深入分析
tags: node
categories: node
date: 2020-11-02
index_img: /img/node_1.jpg
---

## 系统体系

### 工作流程

<img src='/img/node_2.png' width=550 /> 

1. 我们写的 js 代码是在 application 应用层，并通过 v8 引擎去边解析代码边执行。

2. 当然 v8 是不能直接和 libuv 通信的，他需要去调用操作系统底层的方法，当然操作系统的方法他也不能直接调用，**这时候 NODE.JS BINDINGS 就登场了**。

3. **真正体现 node 功能的是 NODE.JS BINDINGS**，他封装了操作系统底层的方法，让 v8 可以直接调用。如我们需要去向一个文件写内容，这时候 v8 通过 BINDINGS 封装的操作系统方法将事件放到 libuv 的 EventQueue 中，然后通知 WORKER THREADS 操作系统开始工作，等操作系统工作完了再通过事件循环去 EventQueue 中找到注册的事件。

4. Event Loop 事件循环的大致流程是：可以想象它是一个可以转的圈，接住 WORKER THREADS 操作系统传来的 api 方法，拿到 api 后去 EventQueue 中找对应的事件，然后通知 v8 开始执行事件的回调函数，最后映射到我们写的应用上。

5. nodejs 费了这么大事主要是为了**实现异步非阻塞式 IO**。

### 细节分析

>   node 到底是单线程还是多线程的？   

1. 在 v8 解释和执行 js 代码时是单线程处理的。但 nodejs 本身是多线程的，是因为在 node 中，v8 单独一个线程，libuv 单独一个线程，剩下会有很多个 WORKER THREADS 真正的工作线程，多个线程相互协作，所以说是多线程的。

2. **所以说可以用 nodejs 写出多线程的程序**。 但是不能常规方法去写在 application 层，而需要通过 node 暴露出来的特殊接口去写 WORKER THREADS。

>   为什么说 node 不适合 cpu 密集型应用，适合 IO 密集型应用？

1. 首先不适合指的是没有充分利用 cpu 的资源，才叫不适合。

2. 因为 nodejs 执行是单线程的，如果执行 CPU 密集的任务就会阻塞后续代码，且单线程无法充分利用 CPU 多核资源。 

3. 而异步 I/O 是多线程的，在工作线程上执行，不会阻塞主线程。当然 NodeJS 也可以通过 child_process 等方式，启用多进程或多线程来处理 CPU 密集型的任务，但相比其它成熟的方案并没有任何优势。

>   什么是异步非阻塞式 IO ？

1. 异步非阻塞式模型就是可以并行处理 IO 操作的模型。

2. 主线程负责处理主要逻辑，那么当有 IO 操作时，新建一个子线程去处理，**当子线程有了返回结果再通过进程间通信给到主线程**。这样主线程就比较空闲就可以去做别的事情。

>   拥有异步I/O的node为什么可以支持高并发呢？

1. 因为 I/O 操作是由 node 的工作线程去执行的（底层的 libuv 是多线程的线程池，用来并行 IO 操作），且主线程是不需要等待结果返回的，只要发出指令马上就可以去忙其他事情了。

2. 虽然 node 的I/O操作开启了多线程，但是所有线程都是基于 **node 服务进程**开启的，并不能充分利用cpu资源，**使用 pm2 进程管理器（pm2 下章会介绍）可以解决这个问题**。   

### node 结构
<img src='/img/node_3.png' width=400 /> 

1. node 通过 NODE.JS BINDINGS 整合了 v8 和 libuv 这个库，并且可以通过 Add-Ons 引入第三方模块（加密、http 等）。

2. 当 node 程序启动后，会有一个主线程，**v8 是在主线程上运行的**，别的例如事件循环、IO 等异步操作是在其它线程上工作的。

3. NODE.JS BINDINGS 实现了类似插槽的功能，允许继承第三方库、并且经过封装后可暴露 API 供程序调用。
